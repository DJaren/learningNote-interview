### 1.Java代码是怎么运行的？
    Java 虚拟机具体是怎样运行 Java 字节码的？
从虚拟机以及底层硬件两个角度，给你讲一讲
从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加
载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代
码。
![](http://ww1.sinaimg.cn/large/b06adeeegy1g0jne8gsbwj20fc0aujs7.jpg)
Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的
native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。

在 HotSpot 里面，上述翻译过程有两种形式：
![](http://ww1.sinaimg.cn/large/b06adeeegy1g0jneuajf7j20n00bpmy0.jpg)
第一种是解释执行，即逐条将字节码翻译成机器码并执行；

第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编
译成机器码后再执行。

总结：
之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可
以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，代替我们
处理部分冗长而且容易出错的事务，例如内存管理。
Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本
地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。
为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。
它会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译
成机器码后直接运行在底层硬件之上。
HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。


### 2.Java的八种基本类型
![](http://ww1.sinaimg.cn/large/b06adeeegy1g0jqoefwg0j20h90a8gnx.jpg)
boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为
0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。
除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均
为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及
NaN 的情况。
除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但
它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或者数组单元
时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。
  
  
  ###  3.java虚拟机是如何加载虚拟类的
  Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化
  三大步骤。
  
  加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载
  器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。
  
  链接（验证准备解析），是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析
  三个阶段。其中，解析阶段为非必须的。
  
  初始化，则是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。类的初始化仅会被执
  行一次，这个特性被用来实现单例的延迟初始化。
  
  
 #### 解释字节流的来源：
  
 Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（referencetypes）。
 Java 的基本类型，它们是由 Java 虚拟机预先定义好的。

另一大类引用类型，Java 将其细分为四种：类、接口、数组类和泛型参数。由于泛型参数会在
编译过程中被擦除（我会在专栏的第二部分详细介绍），因此 Java 虚拟机实际上只有前三种。在
类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。

#### 类的初始化何使会被触发：
1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发
该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

####4.JVM是如何执行方法调用的（上）
1:方法重载

方法名相同、方法参数类型不同（其中包括参数的个数、类型、次序，三者之中只要有一个不同就
行）。以前的理解方法重载是在一个类内，今天读后感觉类间有继承关系也是存在方法重载的，需
要验证一下？

2:方法重写

方法名相同、方法参数类型相同、方法返回值相同，类之间有继承关系，便构成方法重写。

3:JVM定位目标方法的关键是类名+方法名+方法参数类型+方法返回值类型于是就出现了两种JVM找目标方法的方式，静态绑定、动态绑定

4:静态绑定

在解析时JVM便知道该调用那个目标方法，（重载属于静态绑定）

5:动态绑定

在运行时JVM需要根据对应的类类型来具体定位应该调用那个目标方法。对于方法重写，对应的类
会拥有一个方法表（一个二维数组表，给方法标上序号，重写的方法序号一致）（子类重写属于动态绑定）

 ### 5.JVM是如何执行方法调用的 (下)
#### 虚方法调用在 Java 虚拟机中的实现方式。

1:虚方法

方法重写的方法，可认为就是虚方法

2:JVM怎么执行虚方法

通过方法表，一个二维表结构，标示出类的类型、虚方法的序号。当调用虚方法的时候，先确定类
型，再根据类型找方法

 虚方法调用包括 invokevirtual 指令和 invokeinterface 指令。如果这两种指令所声明的目标方法被
 标记为 fnal，那么 Java 虚拟机会采用静态绑定。否则，Java 虚拟机将采用动态绑定，在运行过程
 中根据调用者的动态类型，来决定具体的目标方法。
 
 Java 虚拟机的动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，
 与父类方法表中被重写的方法的索引值一致。在解析虚方法调用时，Java 虚拟机会纪录下所声明的
 目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。
 
 Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将
 纪录调用者的动态类型，以及它所对应的目标方法。
 
 当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。否
 则，Java 虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动
 态绑定。
 
 ### 6.JVM是如何处理异常的？
 
 抛出异常可分为显式和隐式两种。
 1. 显式抛异常的主体是应用程序，它指的是在程序中使用“throw”关
 键字，手动将异常实例抛出。
 
 2. 隐式抛异常的主体则是 Java 虚拟机，它指的是 Java 虚拟机在执行过程中，碰到无法继续执行的异
 常状态，自动抛出异常
![](http://ww1.sinaimg.cn/large/b06adeeely1g0ky3g3gufj20o20g4dgf.jpg)
所有异常都是 Throwable 类或者其子类的实例。Throwable 有两大直接子
类。第一个是 Error，涵盖程序不应捕获的异常。当程序触发 Error 时，它的执行状态已经无法恢
复，需要中止线程甚至是中止虚拟机。第二子类则是 Exception，涵盖程序可能需要捕获并且处理
的异

 在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理
 器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码
 索引（bytecode index，bci），用以定位字节码。
 
 当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引
 值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否
 匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。


### 7.JVM是如何实现反射的？

#### 什么是反射：
    反射是 Java 语言中一个相当重要的特性，它允许正在运行的 Java 程序观测，甚至是修改程序的动态行为
在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过 15 次
之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接
使用 invoke 指令来调用目标方法。（委派实现到动态实现的过程这个过程我们称之为 Infation）

方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的 Object 数组，基本
类型的自动装箱、拆箱，还有最重要的方法内联


### 8|9.JVM是怎么实现 invokedynamic的？（上|下）

invokedymaic 指令抽象出调用点的概念，并且将调用该调用点所链接的方法句柄。在第一次执行invokedynamic 指令时，Java 虚拟机将执行它所对应的启动方法，生成并且绑定一个调用点。之后
如果再次执行该指令，Java 虚拟机则直接调用已经绑定了的调用点所链接的方法。

Lambda 表达式到函数式接口的转换是通过 invokedynamic 指令来实现的。该 invokedynamic 指
令对应的启动方法将通过 ASM 生成一个适配器类。

对于没有捕获其他变量的 Lambda 表达式，该 invokedynamic 指令始终返回同一个适配器类的实
例。对于捕获了其他变量的 Lambda 表达式，每次执行 invokedynamic 指令将新建一个适配器类
实例。

不管是捕获型的还是未捕获型的 Lambda 表达式，它们的性能上限皆可以达到直接调用的性能。其
中，捕获型 Lambda 表达式借助了即时编译器中的逃逸分析，来避免实际的新建适配器类实例的操作。

### 10.Java对象的内存布局


常见的 new 语句会被编译为 new 指令，以及对构造器的调用。每个类的构造器皆会直接或者间接
调用父类的构造器，并且在同一个实例中初始化相应的字段。
Java 虚拟机引入了压缩指针的概念，将原本的 64 位指针压缩成 32 位。压缩指针要求 Java 虚拟机
堆中对象的起始地址要对齐至 8 的倍数。Java 虚拟机还会对每个类的字段进行重排列，使得字段也
能够内存对齐。

#### 1:Java中创建对象的方式
1-1:new -通过调用构造器来初始化实例字段

1-2:反射-通过调用构造器来初始化实例字段

1-3:Object.clone-通过直接复制已有的数据，来初始化新建对象的实例字段

1-4:反序列化-通过直接复制已有的数据，来初始化新建对象的实例字段

1-5:Unsafe.allocateInstance-没有初始化对象的实例字段

#### 2:Java对象的空间占用

2-1:通过new创建的对象，涵盖了它所有父类中的对象实例的字段

2-2:对象头，由标记字段和类型指针构成

2-3:标记字段，用于存储Java虚拟机有关该对象的运行数据，比如：哈希码、GC信息、锁信息等

2-4:类型指针，用于指向该对象的类

2-5:此对象的实例字段对应的内存空间

#### 3:压缩指针
JVM的内存空间有限且昂贵，所以，能缩减的就缩减，通过一定的算法改进压缩类型指针的空间后
仍可以寻址到对象的实例对应的类，将原本的 64 位指针压缩成 32 位。压缩指针要求 Java 虚拟机
堆中对象的起始地址要对齐至 8 的倍数。
4:字段重排

意思是JVM会重新分配字段的位置，和我们Java源码中属性声明的位置存在差异，猜想Java编译器
编译后的字节码是没有改变源码中字段声明的位置的，这样做是为了更好的实现内存对齐，内存对
齐本质上会浪费一定的内存空间，不过可以减少内存行的读取次数，通过一消一涨的比对发现这样
对于JVM的性能有一定的提高，所以，也就使用了这种方式，浪费点空间能提高性能也是值得的
### 11.垃圾回收（上）
Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。它从一系列 GC Roots 出发，
边标记边探索所有被引用的对象。

为了防止在标记过程中堆栈的状态发生改变，Java 虚拟机采取安全点机制来实现 Stop-the-world
操作，暂停其他非垃圾回收线程。

回收死亡对象的内存共有三种方式，
清除法-简单，但易产生碎片，可能总空间够但分配不了的问题

压缩法-能解决清除法的问题，但是复杂且耗性能
                
复制法-折衷一些，但是空间利用率低，总之，各有千秋

### 12.垃圾回收（下）
#### 堆划分
![](http://ww1.sinaimg.cn/large/b06adeeegy1g0l2xydcmjj20vn0ac0tm.jpg)
Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个
大小相同的 Survivor 区。
 #### Minor GC
在只针对新生代的 Minor GC 中，Eden 区和非空 Survivor 区的存活对象会被复制到空的 Survivor
区中，当 Survivor 区中的存活对象复制次数超过一15次时，它将被晋升至老年代。为了避免扫描整个老年代，Java 虚拟机引入了名为卡表的技术，大致地标出可能存在老年代到新生代引用的内存区域。
#### Java 虚拟机中的垃圾回收器
 针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是
 标记 - 复制算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版
 本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与
 CMS 一起使用。
 
 针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old
 和 Parallel Old 都是标记 - 压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版
 本。
 
 CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它
 可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个
 压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃 。
 
 G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的
 堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的
 一个。它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃
 圾回收。
 
 G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。
 
 ### 13. Java内存模型
 
 Java 内存模型通过定义了一系列的 happens-before 操作，让应用程序开发者能够轻易地表达不同
 线程的操作之间的内存可见性。
 
 在遵守 Java 内存模型的前提下，即时编译器以及底层体系架构能够调整内存访问操作，以达到性能
 优化的效果。如果开发者没有正确地利用 happens-before 规则，那么将可能导致数据竞争。
 
 Java 内存模型是通过内存屏障来禁止重排序的。对于即时编译器来说，内存屏障将限制它所能做的
 重排序优化。对于处理器来说，内存屏障会导致缓存的刷新操作。
 
 #### 什么是happens-before
 happens-before 关系是用来描述两个操作的内存可见性
 的。如果操作 X happens-before 操作 Y，那么 X 的结果对于 Y 可见。
 1. 解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。
 2. volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。
 3. 线程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。
 4. 线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或
 Thread.join() 判断该线程是否中止）。
 5. 线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的
 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者
 Thread.isInterrupted 调用）。
 6. 构造器中的最后一个操作 happens-before 析构器的第一个操作。
 #### Java 内存模型的底层实现
 Java 内存模型是通过内存屏障（memory barrier）来禁止重排序的。
 对于即时编译器来说，它会针对前面提到的每一个 happens-before 关系，向正在编译的目标方法
 中插入相应的读读、读写、写读以及写写内存屏障。
 
 这些内存屏障会限制即时编译器的重排序操作。以 volatile 字段访问为例，所插入的内存屏障将不
 允许 volatile 字段写操作之前的内存访问被重排序至其之后；也将不允许 volatile 字段读操作之后
 的内存访问被重排序至其之前。
 
 #### 锁，volatile 字段，fnal 字段
1.锁操作同样具备 happens-before 关系。具体来说，解锁操作 happens-before 之后对
 同一把锁的加锁操作。实际上，在解锁时，Java 虚拟机同样需要强制刷新缓存，使得当前线程所修
 改的内存对其他线程可见。不再强制刷新缓存

2.volatile 字段可以看成一种轻量级的、不保证原子性的同步，其性能往往优于（至少不亚于）锁操
   作。然而，频繁地访问 volatile 字段也会因为不断地强制刷新缓存而严重影响程序的性能。，理想情况下对 volatile 字段的使用应当多读少写，并且应当只有一个线程进行写操作。

3.fnal 实例字段则涉及新建对象的发布问题。当一个对象包含 fnal 实例字段时，我们希望其他线程
   只能看到已初始化的 fnal 实例字段。
   因此，即时编译器会在 fnal 字段的写操作后插入一个写写屏障，以防某些优化将新建对象的发布（即将实例对象写入一个共享引用中）重排序至 fnal 字段的写操作之前。
   
   
   
### 14. Java虚拟机是怎么实现 synchronized的？
 Java 虚拟机中 synchronized 关键字的实现，按照代价由高至低可分为重量级锁、轻
量级锁和偏向锁三种。

1. 重量级锁会阻塞、唤醒请求加锁的线程。它针对的是多个线程同时竞争同一把锁的情况。Java 虚拟
机采取了自适应自旋，来避免线程在面对非常小的 synchronized 代码块时，仍会被阻塞、唤醒的
情况。
2. 轻量级锁采用 CAS 操作，将锁对象的标记字段替换为一个指针，指向当前线程栈上的一块空间，存
储着锁对象原本的标记字段。它针对的是多个线程在不同时间段申请同一把锁的情况。
3. 偏向锁只会在第一次请求时采用 CAS 操作，在锁对象的标记字段中记录下当前线程的地址。在之后
的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。它针对的是锁仅会被同一线程持有的
情况。       



### 15. Java语法糖与Java编译器
基本类型和其包装类型之间的自动转换，也就是自动装箱、自动拆箱，是通过加入
[Wrapper].valueOf（如 Integer.valueOf）以及 [Wrapper].[primitive]Value（如 Integer.intValue ）
方法调用来实现的。

Java 程序中的泛型信息会被擦除。具体来说，Java 编译器将选取该泛型所能指代的所有类中层次最
高的那个，作为替换泛型的具体类。

由于 Java 语义与 Java 字节码中关于重写的定义并不一致，因此 Java 编译器会生成桥接方法作为适
配器。

### 16. 及时编译（上）
从 Java 8 开始，Java 虚拟机默认采用分层编译的方式。它将执行分为五个层次，分为为 0 层解释
执行，
1.  层执行没有 profling 的 C1 代码，
2.  层执行部分 profling 的 C1 代码，
3.  层执行全部profling 的 C1 代码，
4.  层执行 C2 代码。

通常情况下，方法会首先被解释执行，然后被 3 层的 C1 编译，最后被 4 层的 C2 编译。
即时编译是由方法调用计数器和循环回边计数器触发的。在使用分层编译的情况下，触发编译的阈
值是根据当前待编译的方法数目动态调整的。

OSR 是一种能够在非方法入口处进行解释执行和编译后代码之间切换的技术。OSR 编译可以用来
解决单次调用方法包含热循环的性能优化问题。


### 17. 及时编译（下）
通常情况下，解释执行过程中仅收集方法的调用次数以及循环回边的执行次数。
当方法被 3 层 C1 所编译时，生成的 C1 代码将收集条件跳转指令的分支 profle，以及类型相关指
令的类型 profle。在部分极端情况下，Java 虚拟机也会在解释执行过程中收集这些 profle。

基于分支 profle 的优化以及基于类型 profle 的优化都将对程序今后的执行作出假设。这些假设将
精简所要编译的代码的控制流以及数据流。在假设失败的情况下，Java 虚拟机将采取去优化，退回
至解释执行并重新收集相关的 profle

### 18. 即时编译器的中间表达形式
1. 中间表达形式（IR）

在编译原理课程中，我们通常将编译器分为前端和后端。其中，前端会对所输入的程序进行词法分
析、语法分析、语义分析，然后生成中间表达形式，也就是 IR（Intermediate Representation ）。
后端会对 IR 进行优化，然后生成目标代码。
如果不考虑解释执行的话，从 Java 源代码到最终的机器码实际上经过了两轮编译：Java 编译器将
Java 源代码编译成 Java 字节码，而即时编译器则将 Java 字节码编译成机器码。
对于即时编译器来说，所输入的 Java 字节码剥离了很多高级的 Java 语法，而且其采用的基于栈的
计算模型非常容易建模。因此，即时编译器并不需要重新进行词法分析、语法分析以及语义分析，
而是直接将 Java 字节码作为一种 IR。
![](http://ww1.sinaimg.cn/large/b06adeeegy1g0l9v2ijp0j20or0bamzl.jpg)
具体来说，C2 和 Graal 采用的是一种名为 Sea-of-Nodes 的 IR，其特点用 IR 节点来代表程序中的
值，并且将源程序中基于变量的计算转换为基于值的计算。




#### 虚拟机总结


 JVM垃圾处理方法(标记清除、复制、标记整理)
 
• 标记-清除算法

标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象

清除阶段：清除所有未被标记的对象

• 复制算法

○ 将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内
存块中，然后清除正在使用的内存块中的所有对象。

• 标记-整理

○ 标记阶段：先通过根节点，标记所有从根节点开始的可达对象，为被标记的为垃圾对象

○ 整理阶段：将所有的存活对象压缩到内存的一段，之后清理边界所有的空间

• 三种算法的比较

○ 效率：复制算法 > 标记/整理算法 > 标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如
此）。

○ 内存整齐度：复制算法=标记/整理算法>标记/清除算法。

○ 内存利用率：标记/整理算法=标记/清除算法>复制算法。


 JVM如何GC，新生代，老年代，持久代，都存储哪些东西，以及各个区的作用？

• 新生代

在方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象

参考：深入拆解Java虚拟机极https://time.geekbang.org/column/intro/108