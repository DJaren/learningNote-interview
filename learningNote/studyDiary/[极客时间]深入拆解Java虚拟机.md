### Java代码是怎么运行的？
    Java 虚拟机具体是怎样运行 Java 字节码的？
从虚拟机以及底层硬件两个角度，给你讲一讲
从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加
载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代
码。
![](http://ww1.sinaimg.cn/large/b06adeeegy1g0jne8gsbwj20fc0aujs7.jpg)
Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的
native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。

在 HotSpot 里面，上述翻译过程有两种形式：
![](http://ww1.sinaimg.cn/large/b06adeeegy1g0jneuajf7j20n00bpmy0.jpg)
第一种是解释执行，即逐条将字节码翻译成机器码并执行；

第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编
译成机器码后再执行。

总结：
之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可
以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，代替我们
处理部分冗长而且容易出错的事务，例如内存管理。
Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本
地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。
为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。
它会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译
成机器码后直接运行在底层硬件之上。
HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。


### Java的八种基本类型
![](http://ww1.sinaimg.cn/large/b06adeeegy1g0jqoefwg0j20h90a8gnx.jpg)
boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为
0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。
除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均
为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及
NaN 的情况。
除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但
它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或者数组单元
时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。
  
  
  ###  java虚拟机是如何加载虚拟类的
  Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化
  三大步骤。
  
  加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载
  器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。
  
  链接（验证准备解析），是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析
  三个阶段。其中，解析阶段为非必须的。
  
  初始化，则是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。类的初始化仅会被执
  行一次，这个特性被用来实现单例的延迟初始化。
  
  
 #### 解释字节流的来源：
  
 Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（referencetypes）。
 Java 的基本类型，它们是由 Java 虚拟机预先定义好的。

另一大类引用类型，Java 将其细分为四种：类、接口、数组类和泛型参数。由于泛型参数会在
编译过程中被擦除（我会在专栏的第二部分详细介绍），因此 Java 虚拟机实际上只有前三种。在
类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。

#### 类的初始化何使会被触发：
1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发
该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

####4.JVM是如何执行方法调用的（上）
1:方法重载

方法名相同、方法参数类型不同（其中包括参数的个数、类型、次序，三者之中只要有一个不同就
行）。以前的理解方法重载是在一个类内，今天读后感觉类间有继承关系也是存在方法重载的，需
要验证一下？

2:方法重写

方法名相同、方法参数类型相同、方法返回值相同，类之间有继承关系，便构成方法重写。

3:JVM定位目标方法的关键是类名+方法名+方法参数类型+方法返回值类型于是就出现了两种JVM找目标方法的方式，静态绑定、动态绑定

4:静态绑定

在解析时JVM便知道该调用那个目标方法，（重载属于静态绑定）

5:动态绑定

在运行时JVM需要根据对应的类类型来具体定位应该调用那个目标方法。对于方法重写，对应的类
会拥有一个方法表（一个二维数组表，给方法标上序号，重写的方法序号一致）（子类重写属于动态绑定）

 ### 5.JVM是如何执行方法调用的 (下)
####虚方法调用在 Java 虚拟机中的实现方式。
1:虚方法

方法重写的方法，可认为就是虚方法

2:JVM怎么执行虚方法

通过方法表，一个二维表结构，标示出类的类型、虚方法的序号。当调用虚方法的时候，先确定类
型，再根据类型找方法

 虚方法调用包括 invokevirtual 指令和 invokeinterface 指令。如果这两种指令所声明的目标方法被
 标记为 fnal，那么 Java 虚拟机会采用静态绑定。否则，Java 虚拟机将采用动态绑定，在运行过程
 中根据调用者的动态类型，来决定具体的目标方法。
 
 Java 虚拟机的动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，
 与父类方法表中被重写的方法的索引值一致。在解析虚方法调用时，Java 虚拟机会纪录下所声明的
 目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。
 
 Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将
 纪录调用者的动态类型，以及它所对应的目标方法。
 
 当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。否
 则，Java 虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动
 态绑定。
 
 